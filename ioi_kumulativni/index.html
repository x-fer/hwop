<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="../css/style.css" />
    <title>Savjeti koji se ponavljaju</title>
  </head>
  <body class="markup">
    <div class="markup-container"><!--h0--><h2><a name="Savjeti_koji_se_ponavljaju"></a>Savjeti koji se ponavljaju</h2>



<!--h1--><h4><a name="scanf_i_asterix"></a>scanf i asterix</h4>



<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="nf" data-symbol-name="scanf">scanf</span><span class="o">(</span><span class="s2">&quot;%d%d%*d&quot;</span><span class="o">,</span> <span class="o">&amp;</span><span class="no">a</span><span class="o">,</span> <span class="o">&amp;</span><span class="no">b</span><span class="o">);</span></pre></div>

<p><a href="http://stackoverflow.com/questions/2155518/what-is-scanfs-and-scanfd-format-identifiers/2155555#2155555" target="_blank">netko citira standard</a></p>

<p>Ukratko, konverzija koja ima znak * znaci da se parametar parsa ali discarda.</p>

<p>Isto tako, razmak u scanf formatu je gotovo uvijek nepotreban. Onda kada je stavljen predstavlja bilo koji niz praznina. Posebno biti oprezan kada se mijesa scanf(&quot;%c&quot;, ..), getline i cin. To bolje ne raditi :)</p>

<!--h2--><h4><a name="makro"></a>makro</h4>

<p>Ovo bi moglo ici u <strong>knjiznicu</strong>.</p>

<div class="remarkup-code-block" data-code-lang="c" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="cp">#define sort(V) sort(V.begin(), V.end())</span>

<span class="cp">#define reverse(V) reverse(V.begin(), V.end())</span>

<span class="cp">#define unique(V) do {\</span>
<span class="cp">    sort(V); \</span>
<span class="cp">    V.resize(unique(V.begin(), V.end()) - V.begin());\</span>
<span class="cp">  } while (0)</span>

<span class="c1">// #define debug</span>
<span class="cp">#ifdef debug</span>
<span class="cp">#define print(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define print(x)</span>
<span class="cp">#endif</span></pre></div>

<p>makro-e debagiramo pozivom samo preprocesora <tt>g++ -E a.cpp</tt>. ova naredba ispisuje potpuno preprocesani kod.</p>

<!--h3--><h4><a name="c_konstruktori"></a>c++ konstruktori</h4>

<p>pair&lt;int, int&gt; ima defaultni konstruktor koji prima dva integera i radi ocekivanu stvar. stoga:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">pair</span><span class="o">&lt;</span><span class="no">int</span><span class="o">,</span> <span class="no">int</span><span class="o">&gt;</span> <span class="nf" data-symbol-name="par">par</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c">// da</span>
<span class="no">pair</span><span class="o">&lt;</span><span class="no">int</span><span class="o">,</span> <span class="no">int</span><span class="o">&gt;</span> <span class="no">par</span> <span class="o">=</span> <span class="nf" data-symbol-name="make_pair">make_pair</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c">// ne, sporije je. dvaput instanciramo par.</span></pre></div>

<p>nasljedjivanje konstruktora u strukturi</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">struct</span> <span class="no">a</span> <span class="o">{</span>
  <span class="no">int</span> <span class="no">x</span><span class="o">,</span> <span class="no">y</span><span class="o">;</span>
  <span class="nf" data-symbol-name="a">a</span><span class="o">(</span><span class="no">int</span> <span class="no">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="no">int</span> <span class="no">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="nf" data-symbol-name="x">x</span><span class="o">(</span><span class="no">x</span><span class="o">),</span> <span class="nf" data-symbol-name="y">y</span><span class="o">(</span><span class="no">y</span><span class="o">)</span> <span class="o">{}</span> <span class="c">// da</span>
  <span class="nf" data-symbol-name="a">a</span><span class="o">(</span><span class="no">int</span> <span class="no">_x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="no">int</span> <span class="no">_y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="no">x</span> <span class="o">=</span> <span class="no">_x</span><span class="o">;</span> <span class="no">y</span> <span class="o">=</span> <span class="no">_y</span><span class="o">;}</span> <span class="c">// da, ali k znakova duze i dok pregledavam</span>
  <span class="c">// kod malo mi duze treba da provjerim jesu li svi pripadajuci elementi OK pridruzeni</span>
<span class="o">};</span></pre></div>

<p>Sto se tice obicnih podataka kao sto je int, sljedece dvije linije su u C++ ekvivalentne.</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">int</span> <span class="nf" data-symbol-name="x">x</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="no">int</span> <span class="no">x</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span></pre></div>

<p>Recimo da nam se druga vise svidja.</p>

<!--h4--><h4><a name="o_preciznosti_tipa_podataka_double"></a>o preciznosti tipa podataka double</h4>

<p>Svaki integer se moze bez greske prikazati kao double. Svaki long long NE.</p>

<p>To znaci da:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">long</span> <span class="no">long</span> <span class="no">x</span><span class="o">;</span>
<span class="nf" data-symbol-name="assert">assert</span><span class="o">((</span><span class="no">long</span> <span class="no">long</span><span class="o">)</span> <span class="o">(</span><span class="no">double</span><span class="o">)</span> <span class="no">x</span> <span class="o">==</span> <span class="no">x</span><span class="o">);</span></pre></div>

<p>ne mora biti istinito uvijek. No, ako je x integer, onda da. Isto tako, koliko se koraka izvrsava ova petlja:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="k">for</span> <span class="o">(</span><span class="no">double</span> <span class="no">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="no">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">;</span> <span class="no">x</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="o">);</span></pre></div>

<p>?</p>

<!--h5--><h4><a name="gdje_su_struct_i_class_dvije_sestre"></a>gdje su struct i class, dvije sestre ...</h4>

<p><tt>struct</tt> i <tt>class</tt> su u C++ skoro sinonimi. nama glavna bitna razlika je sto u <tt>struct</tt> svi clanovi su <tt>public by default</tt>, dok su u klasi svi prvatni.</p>

<p>dakle kod</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="k">class</span> <span class="no">a</span> <span class="o">{</span>
  <span class="k">public</span><span class="o">:</span>
   <span class="o">...</span>
   <span class="o">...</span>
<span class="o">};</span></pre></div>

<p>je ekvivalentan</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">struct</span> <span class="no">a</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">};</span></pre></div>

<p>Druga razlika ima veze s nasljedjivanjem i ona je <tt>out of scope</tt>. Smatram da u natjecateljskim implementacijama gotovo nikad nece biti potrebno koristiti nesto privatno.</p>

<p><a href="http://blog.stevedoria.net/20050913/differences-between-cpp-classes-and-structs" target="_blank">http://blog.stevedoria.net/20050913/differences-between-cpp-classes-and-structs</a></p>

<!--h6--><h4><a name="naucimo_reference"></a>naucimo reference.</h4>



<div class="remarkup-code-block" data-code-lang="c" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="c1">// primi vlasnistvo neke varijable iz nekog drugo scope-a. u ovom scopu (ovoj</span>
<span class="c1">// funkciji) ta varijabla ce se zvati v. funkcija poveca varijablu s kojom je</span>
<span class="c1">// pozovemo.</span>
<span class="c1">// ovo je najbrzi prijenos neke varijable u funkciju jer se ne kopira ama bas</span>
<span class="c1">// nista. zbog toga smijemo onda prenositi cijele map-e, set-ove i vektore bez</span>
<span class="c1">// straha da ce raditi sporo. no potrebno je paziti da su efekti koje napravimo</span>
<span class="c1">// nad paremetrom v vidljivi pozivatelju.</span>
<span class="c1">// parametar s kojim zovemo funkciju f MORA biti cvrsta varijabla koju vidimo</span>
<span class="c1">// iz pozivajuceg scope-a.</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">++</span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// primi vlasnistvo varijable v ali zbog const-a kompajler te stiti da neces</span>
<span class="c1">// mijenjati taj v. dakle smijemo ga samo citati.</span>
<span class="c1">// ovdje mozemo koristiti cinjenicu da nema nikakvog kopiranja i nemat straha da</span>
<span class="c1">// cemo nastetiti pozivatelju (promijeniti mu nesto cega nije svjestan).</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">broj_pet</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">5</span><span class="p">;}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// x je lokalna varijabla u ovom scopeu</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="c1">// funkciji f dajemo pravo da dira nas x. ona ce ga povecati.</span>
  <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="c1">// funkciji g dajemo pravo da CITA nas x (zbog const int &amp;v), ona ce samo</span>
  <span class="c1">// vratiti (x + 1) u ovom slucaju.</span>
  <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="c1">// sto ocekujemo od ovog poziva? ajmo probat rijecima:</span>
  <span class="c1">// funkciji f dajemo pravo da dira .. ? drugu funkcjiu ? njenu povratnu</span>
  <span class="c1">// vrijednost? recimo da mozemo dirati njenu povratnu vrijednost (to je u</span>
  <span class="c1">// ovom slucaju broj 5), koji je efekt od toga sto smo povecali za jedan</span>
  <span class="c1">// privremeni objekt? kompajler ce ovdje prepoznati nebulozu i dati gresku.</span>
  <span class="n">f</span><span class="p">(</span><span class="n">broj_pet</span><span class="p">());</span>

  <span class="c1">// isto tako, &quot;5&quot; nije varijabla cije vlasnistvno mozemo predati nekoj</span>
  <span class="c1">// funkciji. compile error.</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></div>

<p>Poruka kompajlera:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">ref</span><span class="o">.</span><span class="no">cpp</span><span class="o">:</span> <span class="no">In</span> <span class="k">function</span> <span class="no">‘int</span> <span class="nf" data-symbol-name="main">main</span><span class="o">()</span><span class="no">’</span><span class="o">:</span>
<span class="no">ref</span><span class="o">.</span><span class="no">cpp</span><span class="o">:</span><span class="mi">44</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span> <span class="no">error</span><span class="o">:</span> <span class="no">invalid</span> <span class="no">initialization</span> <span class="no">of</span> <span class="no">non</span><span class="o">-</span><span class="k">const</span> <span class="no">reference</span> <span class="no">of</span> <span class="no">type</span> <span class="no">‘int</span><span class="o">&amp;</span><span class="no">’</span> <span class="no">from</span> <span class="no">an</span> <span class="no">rvalue</span> <span class="no">of</span> <span class="no">type</span> <span class="no">‘int’</span>
<span class="no">ref</span><span class="o">.</span><span class="no">cpp</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span><span class="mi">5</span><span class="o">:</span> <span class="no">error</span><span class="o">:</span> <span class="no">in</span> <span class="no">passing</span> <span class="no">argument</span> <span class="mi">1</span> <span class="no">of</span> <span class="no">‘int</span> <span class="nf" data-symbol-name="f">f</span><span class="o">(</span><span class="no">int</span><span class="o">&amp;)</span><span class="no">’</span>
<span class="no">ref</span><span class="o">.</span><span class="no">cpp</span><span class="o">:</span><span class="mi">48</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span> <span class="no">error</span><span class="o">:</span> <span class="no">invalid</span> <span class="no">initialization</span> <span class="no">of</span> <span class="no">non</span><span class="o">-</span><span class="k">const</span> <span class="no">reference</span> <span class="no">of</span> <span class="no">type</span> <span class="no">‘int</span><span class="o">&amp;</span><span class="no">’</span> <span class="no">from</span> <span class="no">an</span> <span class="no">rvalue</span> <span class="no">of</span> <span class="no">type</span> <span class="no">‘int’</span>
<span class="no">ref</span><span class="o">.</span><span class="no">cpp</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span><span class="mi">5</span><span class="o">:</span> <span class="no">error</span><span class="o">:</span> <span class="no">in</span> <span class="no">passing</span> <span class="no">argument</span> <span class="mi">1</span> <span class="no">of</span> <span class="no">‘int</span> <span class="nf" data-symbol-name="f">f</span><span class="o">(</span><span class="no">int</span><span class="o">&amp;)</span><span class="no">’</span></pre></div>



<!--h7--><h4><a name="jedini_ternarni_operator_u_C"></a>jedini ternarni operator u C</h4>

<p>Izraz</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="o">(</span><span class="no">condition</span> <span class="o">?</span> <span class="no">when_true</span> <span class="o">:</span> <span class="no">when_false</span><span class="o">)</span></pre></div>

<p>ima vrijednost <tt>when_true</tt> ako je <tt>condition</tt> ekvivalentno sa true (odnosno <tt>condition::bool == true</tt>, odnosno <tt>condition</tt> nije nula za brojeve), u suprotnom izraz ima vrijednost <tt>when_false</tt>.</p>

<p>Pomocu ovog operatora mozemo jedno-linijski zapisati neke poznate funkcije:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">int</span> <span class="nf" data-symbol-name="veci">veci</span><span class="o">(</span><span class="no">int</span> <span class="no">a</span><span class="o">,</span> <span class="no">int</span> <span class="no">b</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">a</span> <span class="o">&gt;</span> <span class="no">b</span> <span class="o">?</span> <span class="no">a</span> <span class="o">:</span> <span class="no">b</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="manji">manji</span><span class="o">(</span><span class="no">int</span> <span class="no">a</span><span class="o">,</span> <span class="no">int</span> <span class="no">b</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">a</span> <span class="o">&lt;</span> <span class="no">b</span> <span class="o">?</span> <span class="no">a</span> <span class="o">:</span> <span class="no">b</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="absolutno">absolutno</span><span class="o">(</span><span class="no">int</span> <span class="no">x</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="no">x</span> <span class="o">:</span> <span class="o">-</span><span class="no">x</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="faktorijela">faktorijela</span><span class="o">(</span><span class="no">int</span> <span class="no">n</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">n</span> <span class="o">?</span> <span class="no">n</span> <span class="o">*</span> <span class="nf" data-symbol-name="faktorijela">faktorijela</span><span class="o">(</span><span class="no">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="gcd">gcd</span><span class="o">(</span><span class="no">int</span> <span class="no">a</span><span class="o">,</span> <span class="no">int</span> <span class="no">b</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">a</span> <span class="o">%</span> <span class="no">b</span> <span class="o">?</span> <span class="nf" data-symbol-name="gcd">gcd</span><span class="o">(</span><span class="no">b</span><span class="o">,</span> <span class="no">a</span> <span class="o">%</span> <span class="no">b</span><span class="o">)</span> <span class="o">:</span> <span class="no">b</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="popcount">popcount</span><span class="o">(</span><span class="no">int</span> <span class="no">x</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">x</span> <span class="o">?</span> <span class="o">(</span><span class="no">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="nf" data-symbol-name="popcount">popcount</span><span class="o">(</span><span class="no">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="popcount2">popcount2</span><span class="o">(</span><span class="no">int</span> <span class="no">x</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">x</span> <span class="o">?</span> <span class="o">(</span><span class="no">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="nf" data-symbol-name="popcount">popcount</span><span class="o">(</span><span class="no">x</span> <span class="o">-</span> <span class="o">(</span><span class="no">x</span><span class="o">&amp;-</span><span class="no">x</span><span class="o">))</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;}</span>
<span class="no">int</span> <span class="nf" data-symbol-name="log2">log2</span><span class="o">(</span><span class="no">int</span> <span class="no">x</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="no">x</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf" data-symbol-name="log2">log2</span><span class="o">(</span><span class="no">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;}</span></pre></div>

<p>(probajte provjerit jeli svaka funkcija radi ono sto sam htio da radi, pls)</p>

<!--h8--><h4><a name="komparator_sa_stanjem"></a>komparator sa stanjem</h4>

<p>Nekada je tocke potrebno sortirati po kutu u odnosu na neku ishodisnu tocku. U tom slucaju nam treba komparator koji ce imati pristup toj tocki uvijek. Osim globalne varijable preferiramo i rjesenje:</p>

<div class="remarkup-code-block" data-code-lang="c" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="k">struct</span> <span class="n">cmp_fi</span> <span class="p">{</span>
  <span class="n">pt</span> <span class="n">origin</span><span class="p">;</span>
  <span class="n">cmp_fi</span><span class="p">(</span><span class="n">pt</span> <span class="n">origin</span><span class="p">)</span> <span class="o">:</span> <span class="n">origin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{}</span>
  
  <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">pt</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pt</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ccw</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></pre></div>

<p>takva struktura se moze instancirana predati u <tt>sort</tt> ili instancirati cijeli <tt>set</tt> s njom:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="nf" data-symbol-name="sort">sort</span><span class="o">(</span><span class="no">points</span><span class="o">,</span> <span class="no">points</span> <span class="o">+</span> <span class="no">N</span><span class="o">,</span> <span class="nf" data-symbol-name="cmp_fi">cmp_fi</span><span class="o">(</span><span class="no">p</span><span class="o">));</span>
<span class="no">set</span><span class="o">&lt;</span><span class="no">pt</span><span class="o">,</span> <span class="no">cmp_fi</span><span class="o">&gt;</span> <span class="nf" data-symbol-name="S">S</span><span class="o">(</span><span class="nf" data-symbol-name="cmp_fi">cmp_fi</span><span class="o">(</span><span class="no">p</span><span class="o">));</span></pre></div>

<p>Ovo je posebno lijepo u implementaciji dijkstre.</p>

<!--h9--><h4><a name="const_const_const"></a>const const const ...</h4>

<p><strong>const</strong> je modifier (ide lijevo od deklaracije varijable) koji oznacava da se ta varijabla kroz svoj zivotni vijek nece mijenjati. <strong>const</strong> uglavnom koristimo kako bi zastitili sebe od greske, npr:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="k">const</span> <span class="no">int</span> <span class="no">maxn</span> <span class="o">=</span> <span class="mi">100000</span><span class="o">;</span></pre></div>

<p>program ce raditi isto ako u ovom slucaju nema <tt>const</tt> modifiera, no moze nam se slucajno dogoditi da promijenimo <tt>maxn</tt> i tako izgubimo debug vrijeme. takav tipfeler zapravo i nije tesko napraviti (a tesko ga je uociti, ti su najopasniji):</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="c">// htio sam ispitati jednakost varijabli maxn i it, a napisao sam:</span>
<span class="k">if</span> <span class="o">(</span><span class="no">maxn</span> <span class="o">=</span> <span class="no">it</span><span class="o">)</span> <span class="o">...</span></pre></div>

<p>Buduci da smo definirali <tt>maxn</tt> kao <tt>const</tt>, ovdje ce kompajler javiti gresku.</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code remarkup-counterexample"><span class="no">error</span><span class="o">:</span> <span class="no">assignment</span> <span class="no">of</span> <span class="no">read</span><span class="o">-</span><span class="no">only</span> <span class="no">variable</span> <span class="no">‘maxn’</span></pre></div>

<p>Standardno mjesto gdje koristimo <tt>const</tt> je unutar komparatora, jer tamo gotovo nikad ne zelimo mijenjati objekte koje kompariramo:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">bool</span> <span class="nf" data-symbol-name="cmp">cmp</span><span class="o">(</span><span class="k">const</span> <span class="no">objekt</span> <span class="no">a</span><span class="o">,</span> <span class="k">const</span> <span class="no">objekt</span> <span class="no">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="no">a</span><span class="o">.</span><span class="no">x</span> <span class="o">&lt;</span> <span class="no">b</span><span class="o">.</span><span class="no">x</span><span class="o">;</span>
<span class="o">}</span></pre></div>

<p>Ocito je da nismo mijenjali objekte koje usporedjujemo i nema greske kompajlera.<br />
No, sto ako zelimo usporediti objekte <tt>a</tt> i <tt>b</tt> prema nekoj izracunatoj vrijednosti?</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">bool</span> <span class="nf" data-symbol-name="cmp">cmp</span><span class="o">(</span><span class="k">const</span> <span class="no">objekt</span> <span class="no">a</span><span class="o">,</span> <span class="k">const</span> <span class="no">objekt</span> <span class="no">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="no">a</span><span class="o">.</span><span class="nf" data-symbol-name="eval">eval</span><span class="o">()</span> <span class="o">&lt;</span> <span class="no">b</span><span class="o">.</span><span class="nf" data-symbol-name="eval">eval</span><span class="o">();</span>
<span class="o">}</span></pre></div>

<p>Bez obzira sto <tt>eval()</tt> ne mijenja stanje objekta, ako je nismo deklarirali kako treba, dobiti cemo sljedecu gresku:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code remarkup-counterexample"><span class="no">error</span><span class="o">:</span> <span class="no">passing</span> <span class="no">‘const</span> <span class="no">objekt’</span> <span class="k">as</span> <span class="no">‘this’</span> <span class="no">argument</span> <span class="no">of</span> <span class="no">‘int</span> <span class="nc" data-symbol-name="objekt">objekt</span><span class="o">::</span><span class="nf" data-symbol-context="objekt" data-symbol-name="eval">eval</span><span class="o">()</span><span class="no">’</span> <span class="no">discards</span> <span class="no">qualifiers</span></pre></div>

<p>Kako napisati metodu <tt>eval</tt> da kompajler zna da ona nece mijenjati objekt nad kojim se je pozvala? Odgovor na to pitanje je rjecica <tt>const</tt> poslije parametara metode, a prije viticaste zagrade:</p>

<div class="remarkup-code-block" data-code-lang="php" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="no">struct</span> <span class="no">objekt</span> <span class="o">{</span>
  <span class="no">int</span> <span class="no">x</span><span class="o">;</span>
  <span class="no">int</span> <span class="nf" data-symbol-name="eval">eval</span><span class="o">()</span> <span class="k">const</span> <span class="o">{</span><span class="k">return</span> <span class="no">x</span><span class="o">*</span><span class="no">x</span><span class="o">;}</span>
<span class="o">};</span></pre></div>

<p>Sada sve radi ocekivano.</p>

<p>Potrebno je jos primjetiti da je komparator napisan bez znaka reference <tt>&amp;</tt>, pa zapravo i necemo napraviti stetu ako promijenimo objekt iz parametra jer se je on ionako kopirao (klonirao) u nas komparator. Pravi komparator pisemo tako da &#039;posudimo&#039; vlasnistvo nad objektima koje usporedjujemo (koristeci <tt>&amp;</tt>), osiguramo se da necemo mijenjati to sto smo posudili (koristeci <tt>const</tt>) i onda radimo sto zelimo, a C++ se brine da ni slucajno ni namjerno nismo prekrsili dogovor o <tt>const</tt>-u.</p>

<!--h10--><h4><a name="referenca_u_memoizaciji"></a>referenca u memoizaciji</h4>



<div class="remarkup-code-block" data-code-lang="c" data-sigil="remarkup-code-block"><pre class="remarkup-code"><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">maxn</span><span class="p">][</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">maxn</span> <span class="o">||</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="n">maxn</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// bind ret to a dp[a][b]. it can&#39;t be unbind.</span>
  <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ret</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// do the math.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="n">ret</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

  <span class="c1">// return ret!</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></pre></div>

<p>ovakvim dizajnom rekurzije s memoizacijom uopce ne koristimo novu lokalnu varijablu <tt>ret</tt> za spremanje rjesenja vec rukujemo direktno s vrijednosti u <tt>dp[][]</tt> polju.</p>

<p>ovaj kod se moze zamisliti kao da linije <tt>int &amp;ret = ..</tt> nema, a da sve ispod gdje pise <tt>ret</tt> pise <tt>dp[a][b]</tt>.</p>


    <div style="padding-top: 5px; margin-top: 50px;
      border-top: 1px #ccc solid;text-align:right;margin-left:auto;">
      &copy;&nbsp;<span style="border:0">2013, Anton Grbin</span>
      <a
        rel="license"
        style="display:block;"
        href="http://creativecommons.org/licenses/by-sa/3.0/hr/deed.en_US"
      >
        <img
          alt="Creative Commons License"
          style="margin-left: auto; margin-top: 10px; margin-bottom: 10px;"
          src="/img/cc_88x31.png"
          width="88px" height="31px"/>
      </a>
      <p>
        Ovaj članak objavljen je pod<br/>
        <a
          rel="license"
          href="http://creativecommons.org/licenses/by-sa/3.0/hr/deed.en_US"
        >
          Creative Commons Attribution-ShareAlike 3.0 Croatia License
        </a>
      </p>
    </div>
        </div>
  </body>
</html>